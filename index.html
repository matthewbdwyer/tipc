<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tipc: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tipc
   </div>
   <div id="projectbrief">A TIP to LLVM compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">tipc Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_tipc_tipc_README"></a> <a href="https://github.com/matthewbdwyer/tipc/actions/workflows/build-and-test.yml"><img src="https://github.com/matthewbdwyer/tipc/actions/workflows/build-and-test.yml/badge.svg?branch=main" alt="Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://codecov.io/gh/matthewbdwyer/tipc?branch=main"><img src="https://codecov.io/gh/matthewbdwyer/tipc/coverage.svg?branch=main&amp;flag=codecoverage" alt="codecov.io" style="pointer-events: none;" class="inline"/></a> <a href="https://codecov.io/gh/matthewbdwyer/tipc?branch=main"><img src="https://img.shields.io/endpoint?logo=codecov&amp;logoColor=blue&amp;url=https%3A%2F%2Fmatthewbdwyer.github.io%2Ftipc%2Fdoccoverage.json" alt="codecov.io" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
tipc</h1>
<p>A compiler from TIP to llvm bitcode</p>
<h2><a class="anchor" id="autotoc_md1"></a>
TIP Language, Interpreter, and Analyzers</h2>
<p>TIP is a "Tiny Imperative Programming" language developed by Anders M&amp;#248;ller and Michael I. Schwartzbach for the <a href="https://cs.au.dk/~amoeller/spa/" title="Static Program Analysis">Static Program Analysis</a> lecture notes that they developed for graduate instruction at Aarhus University.</p>
<p>Accompanying those notes is a <a href="https://github.com/cs-au-dk/TIP/">Scala implementation</a> that provides a number of static analysis implementations and interpreter-based evaluators.</p>
<p>This project implements <code>tipc</code> which compiles TIP programs into LLVM bitcode. Linking that bitcode with the <a href="./rtlib">runtime library</a> routines and standard libraries will produce an executable.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Dependencies</h2>
<p><code>tipc</code> is implemented in C++17 and depends on a number of tools and packages, e.g., <a href="https://www.antlr.org">ANTLR4</a>, <a href="https://github.com/catchorg/Catch2">Catch2</a>, <a href="https://cmake.org/">CMake</a>, <a href="https://www.doxygen.nl/">Doxygen</a>, <a href="https://github.com/emilk/loguru">loguru</a>, <a href="https://www.java.com">Java</a>, <a href="https://www.llvm.org">LLVM</a>. To simplify dependency management the project provides a <a href="bin/bootstrap.sh">bootstrap</a> script to install all of the required dependencies on linux ubuntu and mac platforms; if you are using <code>portal.cs.virginia.edu</code> to build then you can replace this script with running <code>module load &lt;pathto&gt;/tipc/conf/modulefiles/tipc/F24</code>, where <code>&lt;pathto&gt;</code> is the path to where you have installed <code>tipc</code>.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Building tipc</h2>
<p>The project uses <a href="https://docs.github.com/en/actions">GitHub Actions</a> for building and testing and <a href="https://codecov.io">CodeCov</a> for reporting code and documentation coverage. The <a href=".github/workflows/build-and-test.yml">build-and-test.yml</a> file provides details of this process. If you would prefer to build and test manually then read on.</p>
<p>After cloning this repository you can build the compiler by moving to into the top-level directory and issuing these commands:</p><ol type="1">
<li><code>./bin/bootstrap.sh</code></li>
<li><code>. ~/.bashrc</code></li>
<li><code>mkdir build</code></li>
<li><code>cd build</code></li>
<li><code>cmake ..</code></li>
<li><code>make</code></li>
</ol>
<p>The build process will download an up to date version of ANTLR4 if needed, build the C++ target for ANTLR4, and then build all of <code>tipc</code> including its substantial body of unit tests. This may take some time - to speed it up use multiple threads in the <code>make</code> command, e.g., <code>make -j6</code>.</p>
<p>You may see some warnings, e.g., CMake policy warnings, due to some of the packages we use in the project. As those projects are updated, to avoid CMake feature deprecation, these will go away.</p>
<p>When finished the <code>tipc</code> executable will be located in <code>build/src/</code>. You can copy it to a more convenient location if you like, but a number of scripts in the project expect it to be in this location so don't move it.</p>
<p>The project includes more than 300 unit tests grouped into several executables. The project also includes more than 90 system tests. These are TIP programs that have built in test oracles that check for the expected results. For convenience, there is a <code>runtests.sh</code> script provided in the <code>bin</code> directory. You can run this script to invoke the entire collection of tests. See the <code>README</code> in the bin directory for more information. <br  />
</p>
<p>All of the tests should pass.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Ubuntu Linux</h3>
<p>Our continuous integration process builds on both Ubuntu 22.04 and 20.04, so these are well-supported. We do not support other linux distributions, but we know that people in the past have ported <code>tipc</code> to different distributions.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Mac OS</h3>
<p>Our continuous integration process builds on macOS 12 and macOS 13 so modern versions of macOS are well-supported. <code>tipc</code> builds on both Intel and Apple Silicon, i.e., Apple's M1 ARM processor. <br  />
</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Windows Subsystem for Linux</h3>
<p>If you are using a Windows machine, tipc can be built in the Windows Subsystem for Linux (WSL). <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10#update-to-wsl-2">Here</a> are instructions to install WSL and upgrade to WSL2. It is highly recommended to upgrade to WSL2. Once installed, you should install <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10#update-to-wsl-2">Ubuntu 20.04</a>. Once finished, you can open a virtual instance of Ubuntu and follow the instructions above to build tipc.</p>
<p>You may recieve an error saying "No CMAKE_CXX_COMPILER could be found" when running <code>cmake ..</code>. If this is the case, you should install g++ with the command: <code>sudo apt-get install g++</code>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Using tipc</h2>
<p>The <code>tipc</code> compiler has a limited set of options available through the <code>--help</code> flag. </p><div class="fragment"><div class="line">OVERVIEW: tipc - a TIP to llvm compiler</div>
<div class="line"> </div>
<div class="line">USAGE: tipc [options] &lt;tip source file&gt;</div>
<div class="line"> </div>
<div class="line">OPTIONS:</div>
<div class="line"> </div>
<div class="line">Generic Options:</div>
<div class="line"> </div>
<div class="line">  --help                 - Display available options (--help-hidden for more)</div>
<div class="line">  --help-list            - Display list of available options (--help-list-hidden for more)</div>
<div class="line">  --version              - Display the version of this program</div>
<div class="line"> </div>
<div class="line">tipc Options:</div>
<div class="line">Options for controlling the TIP compilation process.</div>
<div class="line"> </div>
<div class="line">  --asm                          - emit human-readable LLVM assembly language</div>
<div class="line">  --do                           - disable bitcode optimization</div>
<div class="line">  --log=&lt;logfile&gt;                - log all messages to logfile (enables --verbose 3)</div>
<div class="line">  -o=&lt;outputfile&gt;                - write output to &lt;outputfile&gt;</div>
<div class="line">  --pa=&lt;AST output file&gt;         - print AST to a file in dot syntax</div>
<div class="line">  --pcg=&lt;call graph output file&gt; - print call graph to a file in dot syntax</div>
<div class="line">  --pi                           - perform polymorphic type inference</div>
<div class="line">  --pp                           - pretty print</div>
<div class="line">  --ps                           - print symbols</div>
<div class="line">  --pt                           - print symbols with types (supercedes --ps)</div>
<div class="line">  --verbose=&lt;int&gt;                - enable log messages (Levels 1-3) </div>
<div class="line">                                    Level 1 - Basic logging for every phase.</div>
<div class="line">                                    Level 2 - Level 1 and type constraints being unified.</div>
<div class="line">                                    Level 3 - Level 2 and union-find solving steps.</div>
</div><!-- fragment --><p> By default it will accept a <code>.tip</code> file, parse it, perform a series of semantic analyses to determine if it is a legal TIP program, generate LLVM bitcode, and emit a <code>.bc</code> file which is a binary encoding of the bitcodes. You can see a human readable version of the bitcodes by running <code>llvm-dis</code> on the <code>.bc</code> file.</p>
<p>To produce an executable version of a TIP program, the <code>.bc</code> file must be linked with the bitcode for <a href="rtlib/tip_rtlib.c">tip_rtlib.c</a>. Running the <code>build.sh</code> script in the [rtlib](rtlib) directory once will create that library bitcode file.</p>
<p>The link step is performed using <code>clang</code> which will include additional libraries needed by <a href="rtlib/tip_rtlib.c">tip_rtlib.c</a>. <br  />
</p>
<p>For convenience, we provide a script <a href="bin/build.sh">build.sh</a> that will compile the tip program and perform the link step. The script can be used within this git repository, or if you define the shell variable <code>TIPDIR</code> to the path to the root of the repository you can run it from any location as follows: </p><div class="fragment"><div class="line">$ cd</div>
<div class="line">$ more hello.tip</div>
<div class="line">main() { return 42; }</div>
<div class="line">$ $HOME/tipc/bin/build.sh hello.tip</div>
<div class="line">$ ./hello</div>
<div class="line">Program output: 42</div>
<div class="line">$ $HOME/tipc/bin/build.sh -pp -pt hello.tip</div>
<div class="line">main() </div>
<div class="line">{</div>
<div class="line">  return 42;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Functions : {</div>
<div class="line">  main : () -&gt; int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Locals for function main : {</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Working with tipc</h2>
<p>The instructions above, and the scripts described below, make it possible to develop from the command line. This gives you lots of control, but it means you will miss the benefit of modern IDEs. Below we describe how to set up the CLion IDE for use with the project.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Command line</h3>
<p>During development you need only run build steps 1 through 5 a single time, unless you modify some <code>CMakeLists.txt</code> file. Just run <code>make</code> in the build directory to rebuild after making changes to the source.</p>
<p>If you do need to add a source file then you will have to edit the appropriate <code>CMakeLists.txt</code> file to add it. In this case, you should:</p><ul>
<li><code>cd build</code></li>
<li><code>rm CMakeCache.txt</code></li>
<li><code>cmake ..</code></li>
</ul>
<p>which will regenerate the makefiles that you can then run, by typing <code>make</code>, to build.</p>
<p>Note that the <code>tipg4</code> directory has a standalone ANTLR4 grammar. It's README describes how to build it in isolation and run it using the ANTLR4 jar file.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
The bin directory</h3>
<p>To facilitate development of <code>tipc</code> we have collected a number of helper scripts into the <code>bin</code> directory of the project. Among them are scripts to run the entire test bed (<code>runtests.sh</code>), to run a code coverage analysis (<code>gencov.sh</code>), and to generate the project documentation (<code>gendocs.sh</code>). Please see the <code>README</code> in the bin directory for example usages. <br  />
</p>
<p>When rebuilding and rerunning tests you may get errors about failing to merge <code>gcov</code> files. This happens when <code>gcov</code> files linger from previous runs. To cleanup these messages, simply run the <code>cleancov.sh</code> script.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
CLion</h3>
<p><a href="https://www.jetbrains.com/clion/">CLion</a> is C++ IDE that can be used to develop and build tipc. CLion can be installed with the JetBrains suite of tools, or as a standalone tool <a href="https://www.jetbrains.com/help/clion/installation-guide.html#standalone">here</a>. Once installed, you can start a 30 day trial license or, as a student, you can get a free educational license <a href="https://www.jetbrains.com/community/education/#students">here</a>.</p>
<p>These instructions are with respect to CLion 2023.1.3, but older or new versions work similarly - though the UI may be a bit different.</p>
<p>If you are building for the first time with CLion, follow the first two steps of the installation process to install any needed tipc dependencies.</p>
<p>From the <code>File</code> menu select <code>New</code> and then <code>Project from Version Control</code>. You can type in the URL for this github repository and then hit the <code>Clone</code> button. The scripts described above assume a directory structure, but a little bit of setup will synchronize your CLion project with those assumptions and allow for easy development using both CLion and scripts, when needed.</p>
<p>From the <code>CLion</code> menu select <code>Build, Execution, Deployment</code> and then <code>CMake</code>. You want to change the <code>Build directory</code> to <code>build</code> and then define an <code>Environment</code> variable. When you ran the <code>bootstrap.sh</code> script it defined a shell variable <code>LLVM_DIR</code> in your <code>.bashrc</code>. Copy that definition into the <code>Environment</code> field under <code>Cache variables</code>. Your <code>Settings</code> should look as follows:</p>
<p><img src="clion_settings_for_tipc.png" alt="" class="inline" title="CLion CMake Settings"/></p>
<p>Now you can click <code>Apply</code> and then <code>OK</code> to complete the setup.</p>
<p>The project can now be built or rebuilt by clicking the "Build" button in the toolbar.</p>
<p>CLion has great debugging support as well as test coverage support for the Catch2 tests included in the project. You will rarely need to use the commandline scripts, but if you do just move to <code>~/CLionProjects/tipc</code> and you can execute them there to:</p><ol type="1">
<li>resolve <code>gcov</code> merge errors by running <code>cleancov.sh</code></li>
<li>run system tests with <code>runtests.sh</code></li>
<li>generate documentation with <code>gendocs.sh</code></li>
</ol>
<p>CLion also has some nice plugins. For example, there is an <a href="https://plugins.jetbrains.com/plugin/7358-antlr-v4">ANTLR v4</a> plugin that allows you to more easily develop extensions to the grammar for TIP. Installation is easy, just click on the <code>Install to CLion ...</code> button on the web-page. Then right click on any rule and select <code>Test Rule ...</code> and two frames pop up at the bottom of the UI: the left frame allows you to type in fragments of input and the right frame shows the resulting parse tree.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Log Messages</h3>
<p>When working on the tipc compiler, it may be helpful to enable logging messages when testing your changes on programs. We have inserted logging messages using loguru. These can be turned using the flag <code>--verbose [x]</code> where x is a number between 1-3. These messages get more verbose as you increase x. The first setting shows when symbols are added to the symbol table and when type constraints are generated for the type solver. The second setting shows the previous information and type constraints being unified. The third setting shows types being search for and added into the type graph. When adding to theses features, you can add logging messages by adding a line <code>LOG_S(x)</code> where x is an integer to describe the level of log verbosity you want. You can use the existing levels or make new levels.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Code Style</h2>
<p>tipc follows <a href="https://llvm.org/docs/CodingStandards.html#llvm-coding-standards">llvm coding standards</a>. <code>clang-format</code> is used to apply the llvm style rules. The following command can be used to apply the llvm style across the tipc <code>src</code> directory. </p><div class="fragment"><div class="line">find src -iname *.h -o -iname *.cpp | xargs clang-format -style=llvm -i</div>
</div><!-- fragment --><p>Using <a href="https://pre-commit.com/">pre-commit</a> we can enforce styling before each commit. This is encourged to keep a uniform style across the codebase. Install pre-commit by following the <a href="https://pre-commit.com/#installation">instructions</a> in their documentation. Then, install the tipc hooks by running, </p><div class="fragment"><div class="line">pre-commit install</div>
</div><!-- fragment --><p>Now, <code>c++</code> and <code>cmake</code> formatting will be checked before each commit.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Documentation</h2>
<p>The TIP grammar, <a href="./tipg4/TIP.g4">tipg4</a>, is implemented using ANTLR4. This grammar is free of any semantic actions, though it does use ANTLR4 rule features which allow for control over the tree visitors that form key parts of the compiler. This allows the structure of the grammar to remain relatively clean, i.e., no grammar factoring or stratification needed. <br  />
</p>
<p>The <code>tipc</code> compiler is has a pretty classic design. It is comprised of four phases:</p><ul>
<li><a href="./src/frontend">frontend</a> takes care of parsing, constructing an AST representation, and pretty printing</li>
<li><a href="./src/semantic">semantic analysis</a> that performs assignability, symbol, and type checking</li>
<li><a href="./src/codegen">code generation</a> that produces LLVM bitcode from an AST and emits a binary</li>
<li><a href="./src/optimizer">optimization</a> that runs a few LLVM optimization passes to improve the bitcode</li>
</ul>
<p>Doxygen <a href="https://matthewbdwyer.github.io/tipc">documentation</a> for the project is available for the project. The documentation is a work in progress and will improve over time.</p>
<p>The <code>tipc</code> driver program only produces a bitcode file, <code>.bc</code>. You need to link it with the <a href="./rtlib/tip_rtlib.c">runtime library</a> which define the processing of command line arguments, which is non-trivial for TIP, establish necessary runtime structures, and implement IO routines. A <a href="./bin/build.sh">script</a> is available to link binaries compiled by <code>tipc</code> with the runtime library.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Goals and Plans</h2>
<p>The goal of this project is to provide a starting point for project work in an undergraduate compilers course. As such it similar to lots of other compiler projects, but there are some differences.</p>
<p>First and foremost, the TIP language includes a number of rich features, e.g., high-order functions, and type inference, and the <code>tipc</code> compiler targets LLVM - a key component of a production compiler infrastructure. These choices are intentional and while they create some challenges the project is intended to help demystify complex language features, e.g., parametric polymorphism, by illustrating how they can be realized.</p>
<p>Second, the project attempts to use modern software development practices, e.g. Doxygen for in-code documentation, unit testing with Catch2, continuous integration with GitHub Actions, and code coverage with <code>lcov</code>. <br  />
</p>
<p>Third, the project intentionally makes heavy use of the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor pattern</a> which is quite appropriate in the context of a compiler. Our use of it is intended to demonstrate how this type of abstract design element in a system can yield conceptual simplicity and savings in development. The project currently uses 6 visitors that extend <a href="./src/frontend/ast/ASTVisitor.h">ASTVisitor</a> and another visitor from ANTLR4.</p>
<p>Finally, the project is implemented in C++17 using modern features. For example, all memory allocation uses smart pointers, we use unique pointers where possible and shared pointers as well, to realize the <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> pattern. Again this presents some challenges, but addressing them is illustrated in the <code>tipc</code> code base and hopefully they provide a good example for students. <br  />
</p>
<p>The project is a work-in-progress in the sense that we are planning to perform corrective maintenance, as needed, as well as perfective maintenance. For the latter, we expect to make a new release of the project in early August every year. This release will focus on improving the use of modern C++ and to incorporate better design principles, patterns, and practices. We welcome issue reports and pull-requests along these lines.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Differences from TIP and Limitations</h2>
<p>Other than issues related to the efficiency of the code that it generates, the <code>tipc</code> compiler has two limitations.</p>
<p><code>tipc</code> supports a variant of the TIP language semantics in a few ways. It implements the <code>!=</code> operator which allows us to conveniently write self-contained system tests and it implements the <a href="https://en.cppreference.com/w/c/language/operator_precedence">C operator precedence rules</a>, whereas the original TIP uses a few different rules. This surfaces in the interplay between pointer dereference and field access. An expression <code>*r.f</code> is interpreted as <code>*(r.f)</code> according t the C precedence rules and as <code>(*r).f</code> according to the <a href="https://github.com/cs-au-dk/TIP">TIP Scala</a> implementation. If in doubt, add parentheses to express your meaning.</p>
<p>By default <code>tipc</code> implements the unification-based monomorphic type inference algorithm used in the <a href="https://github.com/cs-au-dk/TIP/">Scala implementation</a>. <code>tipc</code> also support a form of polymorphic type inference using the <code>--pi</code> option. To use polymorphic type inference programmers can add the <code>poly</code> keyword to a function declaration, but <code>tipc</code> will only perform polymorphic type inference for such functions if they are non-recursive.</p>
<p>There is also a difference in type inference related to records. The type system that ensures that any expression appearing in the record position of a field access expression is in fact a record, but it does not infer precise record typing. Instead the strategy used is to define an <em>uber</em> record that consists of all of the fields referenced across the program. Code generation for records will allocate a global record and then explicitly initialize fields present in a record expression. If the record is being created via an <code>alloc</code> expresion, the fields that aren't explictly set will be set to a default value 0, as we allocate memory using the C function <code>calloc</code>. If the record is being created without explictly allocating memory for it, the fields that aren't explictly set will not be given any value, but may still be referenced. This can lead to some unexpected behavior. Consider this TIP program: </p><div class="fragment"><div class="line">main() { var r; r = {g:1}; return access(r); }</div>
<div class="line">access(r) { return r.f; }</div>
</div><!-- fragment --><p> The record expression, <code>{g:1}</code>, forces the global record to contain a field <code>g</code>, and the access expression <code>r.f</code>, forces the presence of field <code>f</code>. Because <code>r</code> is not being allocated using an <code>alloc</code> expression, access will return whatever value was in memory at the location of <code>r.f</code>. One might prefer that this program yield a type error, but that would require a more sophisticated type system. We chose not to implement that to manage the complexity of what is primarily a pedagogical project. If instead, r is allocated using <code>alloc</code> like the following: </p><div class="fragment"><div class="line">main() { var r; r = alloc {g:1}; return access(r); }</div>
<div class="line">access(r) { return r.f; }</div>
</div><!-- fragment --><p> The record expression default initializes <code>f</code> to <code>0</code> and this is the value that is accessed and returned from the call to <code>access</code> and then from <code>main</code>. <br  />
</p>
<p>Second, TIP allows memory allocation, yet its runtime system does not include a garbage collector. <br  />
 The TIP program <a href="test/system/leak/recordLeak.tip">recordLeak.tip</a>, shown below, leaks memory because the <code>alloc</code> constructor causes the record to be allocated on the heap: </p><div class="fragment"><div class="line">// recordLeak.tip</div>
<div class="line">foo(x,y,z){</div>
<div class="line">    var rec;</div>
<div class="line">    rec = alloc {l: x, m: y, n: z};</div>
<div class="line">    return (*rec).m;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">main(){</div>
<div class="line">    var i, j, a;</div>
<div class="line">    a = 0;</div>
<div class="line">    i = 0;</div>
<div class="line">    j = 0;</div>
<div class="line">    while (1000000000 &gt; i) { </div>
<div class="line">      while (1000000000 &gt; j) { </div>
<div class="line">        a = a + foo(3,2,4);</div>
<div class="line">        j = j + 1;</div>
<div class="line">      }</div>
<div class="line">      i = i + 1;</div>
<div class="line">    }</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This is a valid tip program which can be compiled into an executable using and observe it's memory usage using: </p><div class="fragment"><div class="line">/path/to/tipc/bin/build.sh --do test/system/leak/recordLeak.tip</div>
<div class="line">./recordLeak &amp;; top</div>
</div><!-- fragment --><p> You can then kill top using <code>Ctrl+C</code> and then kill the ./recordleak with <code>fg</code> and <code>Ctrl+C</code>. It's important that you disable the optimizer with the <code>--do</code> flag. Otherwise, the optimizer would be smart enough to simply return the <code>y</code> parameter's value. If we remove the alloc from <code>foo</code>, as we do in <a href="test/system/leak/recordNoLeak.tip">recordNoLeak.tip</a>, then the record is allocated on the call stack and it is reclained when the call to <code>foo</code> returns: </p><div class="fragment"><div class="line">// recordNoLeak.tip</div>
<div class="line">foo(x,y,z){</div>
<div class="line">    var rec;</div>
<div class="line">    rec = {l: x, m: y, n: z};</div>
<div class="line">    return (*rec).m;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">main(){</div>
<div class="line">    var i, j, a;</div>
<div class="line">    a = 0;</div>
<div class="line">    i = 0;</div>
<div class="line">    j = 0;</div>
<div class="line">    while (1000000000 &gt; i) { </div>
<div class="line">      while (1000000000 &gt; j) { </div>
<div class="line">        a = a + foo(3,2,4);</div>
<div class="line">        j = j + 1;</div>
<div class="line">      }</div>
<div class="line">      i = i + 1;</div>
<div class="line">    }</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We can find that this program will not create a memory leak because rec will be allocated on the stack instead of the heap as the alloc would. <br  />
</p>
<p>Incorporating a garbage collector is a possible future extension to the runtime library.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Resources</h2>
<p>To fully understand this project quite a bit of background is required. We collect a number of resources that we think can be helpful in that regard.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
C++ Resources</h3>
<p>If you find yourself unfamiliar with certain aspects of the C++ programming language we encourage you to explore the <em>Back To Basics</em> videos that have been presented at <a href="https://cppcon.org/">CppCon</a>. Provided below are links to a number of these videos, as well as to other resources that are relevant to this project.</p>
<h4><a class="anchor" id="autotoc_md19"></a>
Move Semantics</h4>
<ul>
<li><a href="https://youtu.be/St0MNEU5b0o">Move Semantics (part 1 of 2)</a></li>
<li><a href="https://youtu.be/pIzaZbKUw2s">Move Semantics (part 2 of 2)</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md20"></a>
Value Categories</h4>
<ul>
<li><a href="https://youtu.be/XS2JddPq7GQ">Understanding Value Categories</a></li>
<li><a href="https://www.stroustrup.com/terminology.pdf">“New” Value Terminology</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md21"></a>
Smart pointers</h4>
<ul>
<li><a href="https://youtu.be/xGDLkt-jBJ4">Smart Pointers</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md22"></a>
CMake Resources</h3>
<ul>
<li><a href="https://cmake.org/cmake/help/v3.7/">CMake docs</a></li>
<li><a href="https://youtu.be/y7ndUhdQuU8">More Modern CMake</a></li>
<li><a href="https://youtu.be/y9kSr5enrSk">Oh No! More Modern CMake</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md23"></a>
Catch2 and Unit Testing Resources</h3>
<ul>
<li><a href="https://github.com/catchorg/Catch2/tree/master/docs">Catch2 docs</a></li>
<li><a href="https://youtu.be/Ob5_XZrFQH0">Modern C++ Testing with Catch2</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md24"></a>
LLVM Resources</h3>
<p>To understand this code, and perhaps extend it, you will want to become familiar with the <a href="http://llvm.org/docs/ProgrammersManual.html#the-core-llvm-class-hierarchy-reference">core LLVM classes</a>. It can be difficult to absorb all of the information in this type of documentation just by reading it. A goal-directed strategy where you move back and forth between reading code and reading this documentation seems to work well for many people.</p>
<p>If you are familiar with the <a href="https://llvm.org/docs/tutorial/">LLVM tutorial</a> you will see its influence on this compiler which leverages idioms, strategies, and code fragments from the tutorial. The LLVM tutorials are a great starting point for understanding the APIs in the context of compiling.</p>
<p>There is lots of great advice about using LLVM available:</p><ul>
<li><a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html">https://www.cs.cornell.edu/~asampson/blog/llvm.html</a></li>
<li>the <a href="http://llvm.org/docs/ProgrammersManual.html">LLVM Programmer's Manual</a> is a key resource</li>
<li>someone once told me to just use a search engine to find the LLVM APIs and its a standard use case for me, e.g., I don't remember where the docs are I just search for <code>llvm irbuilder</code></li>
<li>LLVM has some nuances that take a bit to understand. For instance, the <a href="https://llvm.org/docs/GetElementPtr.html">GEP</a> instruction, which <code>tipc</code> uses quite a bit given that it emits calls through a function table.</li>
<li>LLVM15+ have implemented the concept of "Opaque Pointers", this removes all the typed pointer implementations and associated functions.<ul>
<li><a href="https://llvm.org/docs/OpaquePointers.html">LLVM Docs on OpaquePointers</a> talks about this in reasonable detail.</li>
<li><a class="el" href="md_OpaquePointers.html">Here</a> is a Quick summary of the change and how that affects tipc. </li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md25"></a>
Git Resources</h3>
<ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git Book</a></li>
<li><a href="https://www.youtube.com/watch?v=1ffBJ4sVUb4">Git For Ages 4 And Up</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
CLion Resources</h3>
<ul>
<li><a href="https://www.jetbrains.com/help/clion/using-git-integration.html">Using Git in CLion</a></li>
<li><a href="https://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-clion.html#wsl-tooclhain">Using CLion with WSL</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
